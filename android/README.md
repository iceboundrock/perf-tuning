#Android App崩溃解决和性能调优总结

##崩溃问题

###见招拆招vs打破沙锅问到底

修复Java崩溃往往是很相对简单的工作，因为崩溃系统里通常会记录下比较消息的调用栈。通过异常类型和调用栈基本就可以定位到出现问题的位置，有时候在出现问题的位置简单的加上try/catch就可以解决崩溃。但是，这样真的解决问题了么？未必！

给大家讲一个StackOverflow引发的<del>血案</del>思考。App中曾经报告了一个异常，原因是遍历某个List时引发了StackOverflow，我Google了很久并没有找到类似的异常，于是就想用try/catch防御一下算了。但是总是觉得不甘心，于是就翻查相关的代码，终于被我找到了幕后真凶。崩溃的原因是在向某个List添加元素后，我们会对其排序，只留下最前面的n个元素，一开始编写这个方法的同学充分考虑了性能问题，决定采用List.subList方法而不是删掉不需要的元素。然而每次subList都会产生一个新的SubAbstractList对象，其fullList字段指向原先的SubAbstractList，然后通过start和end两个索引标记sub list的区域，如下示意图：

```
  SubList_[M]   // 第M次subList之后的对象
    +fullList->SubList_[M-1]
                 +fullList->SubList_[M-2]
                             \
                              \
                              SubList_1
                                +fullList:list  // 最初的list对象
```

一定次数之后再调用SubAbstractList.listIterator就会不断的递归调用其fullList的SubAbstractList.listIterator，导致stack overflow error。彻底解决这个问题其实也非常简单，对最初的list排序之后不要用subList，而是直接删掉最后不要的元素即可。

这虽然是个简单的问题，但是也充分说明了一个道理，简单的try/catch并不能彻底解决问题，反而可能会掩盖问题并且导致更大的麻烦。如果上面的例子中只是简单的catch异常，会导致这个list永远无法被遍历，程序功能出错。


###一些常见的造成崩溃的坑和避免方法

* NPE

    Null Pointer Exception可能是我们日常工作中遇到的最多的异常问题，解决此问题非常简单直接，只要找到崩溃call stack最顶层的方法，在其中加入防御对象引用为null的语句即可。但是如上面谈到的，不要见招拆招，防御了null也许并不是问题的终结而是更严重问题的开始。所以我们需要更加进一步分析并没有什么完美的办法，但是我们可以在工作中采用如下方法尽量的避免这个问题：
        1. Android系统的API基本都会在参数上标注@NonNull、@Nullable注解，在使用API时需要注意查看，并进行适当的防御
        2. 为方法的参数和返回值加上NonNull和Nullable注解，这样可以让lint帮助我们检查潜在的NPE
        
* 异步处理结束时不判断回掉中使用对象的状态
    为了不卡住UI线程，在Android开发中会大量的使用异步处理，也就是在工作线程中处理一些耗时操作，待操作完成后通过handler把执行结果投递到UI线程以操作UI元素。这样的处理会带来一些额外需要注意的地方，尤其是在于fragment打交道的时候。推荐的方法是在post到UI线程的方法里检查依赖的Activity或者View等UI对象的状态：如果Activity已经处于finishing/destroied状态或者View已经从Window deatch，一些操作就不要做了。一方面避免出现问题也是某种意义的优化吧。对于fragment的操作更加需要注意，由于Fragment的生命周期独立于Activity的生命周期，并且在Activity onSaveInstanceState之后，再执行添加或者删除Fragment会抛出异常，所以这里也要特别注意。

* OOM

    Out Of Memory也是一类比较常见的崩溃。造成OOM的原因通常有这么几种
        1. 内存泄漏，慢慢的吃光了内存。造成内存泄漏的原因很多，在Android环境下，一个最主要的原因是由于匿名类型对象引用了其父对象（如Activity/View等）。检测和解决内存泄漏相对来说比较简单，我通常的做法是在工具中观测到内存泄漏后，抓几个heap dump进行对比，观察持续增多的对象并找到他们的GC Root，然后想办法在代码中尽早把GC Root中指向泄露的对象引用清理掉。目前也有leak canary这样的库来帮助我们在运行时检测Activity泄漏，使用起来就更加方便了。
        2. 一下子分配了太大的对象。这种场景往往是要读取Bitmap或者为了读取文件而直接把文件加载到内存中造成。
            * 对于读取Bitmap造成的OOM，主要的解决办法是调整Bitmap的配置。最有效的办法是根据实际显示的尺寸加载图片，通过调整适当的sample size可以大幅降低bitmap的内存占用。另外，如果图片不需要透明，也可以使用RGB565配置加载Bitmap，虽然这样做有一定的图片质量损失，但是为了解决OOM崩溃，还是值得的。
            * 对于直接把文件加载到内存造成的OOM，解决办法需要根据实际场景做判断。一般的做法是使用FileInputStream来渐进的处理文件。但是有时文件的内容可能是某种自定义的网络协议（例如YY协议）的直接存储，我们希望能复用网络协议的处理，在这样的情况下，可以使用MappedByteBuffer方式把文件映射到ByteBuffer，需要注意的是，这样的方式性能比直接读文件要差一些。


###防御性编程

在编写公共类型的公共方法时，尽量的对参数和对象自身状态进行合法性检查。下面几点尤其重要：

1. 必要的参数是否为null，是否处于合法的范围
2. 在异步回调时，相关Activity是否已经处于isFinishing或者isDestroyed状态
3. 在异步回调时，相关View是否已经从Window deteached 
    
##性能调优

*说在前面的话* 
			
兵法讲究攻心为上，攻城为下，性能调优亦是如此。在做性能优化时不要拘泥于技术层面，从产品层面优化往往有更加突出的效果。当然本文的讨论依然集中在技术层面。

###调优方法论

*优化什么*

我认为对于Android App的性能，需要关心的核心指标只有两个：帧率和耗电。CPU、内存之类的指标都是为了这两个指标服务的。本文中我们主要会探讨如何优化帧率，通常我们认为App的帧率保持在60FPS才是流畅的，如何让App的帧率保持在60FPS以上是我们优化的重中之重。耗电的优化我会放到另外的文章里。

*优化之道*

调优与其他事情类似，需要明确的目标才能收到效果。所以我们要先收集数据再进行优化，没有数据依据的优化都是耍流氓。我认为优化的流程应该是：
    1. 收集性能基线数据。包括当前的帧率、CPU、内存、GPU渲染模式、GC频率等数据
    2. 分析性能热点。从基线数据中找到最需要优化的点，然后通过工具分析造成热点的原因。
    3. 根据上面的分析修改代码。
    4. 回到第一步，确认修改是否达到预期效果。如果没有，则继续此循环。如果达到了性能要求，可以终止。


###调优工具介绍

经验很重要，但是经验不能代替工具。Android环境有很多非常方便的性能分析工具，下面就简单列举一下我比较常用的：

1. Android Studio 2.0。Android Stuido不仅仅是开发工具，开发者还可以在Android Studio中非常方便的收集性能数据。尤其是CPU和内存的数据。还可以直接在Android Studio中抓取内存分配和进行Method Profile。
2. Android手机自带的开发者工具
    2.1 GPU呈现模式分析
    2.2 显示硬件层更新
    2.3 调试GPU过度绘制
   
3. DDMS
    3.1 查看布局层次
    3.2 追踪内存分配
    3.3 CPU分析    
    
4. MAT。MAT用于分析heap dump，用于找出内存泄漏的具体原因
5. 第三方性能调优app，包括高通的app turn up kit和腾讯的GT 


###一些调优经验

*内存优化*

虽然Java语言会自动管理内存，但是内存分配依然会带来性能问题。最主要的是由于GC造成的卡顿和CPU使用。我们可以使用Android Studio的Allocation Tracking功能追踪到对象是被那些方法分配的。从这些数据中可以得到内存分配的热点，然后可以优化相关的代码来减少分配。例如使用对象池避免无谓的分配。尤其是一些分配比较耗时或者分配频率比较高但生命周期比较短的对象。创建对象池也有一定的策略：
    1. 对象池要合理设置容量，太小起不到减少分配的作用，太大则造成GC压力。所以要在分配时记录总的分配次数和直接从对象池获取的次数，然后计算命中对象池的比例。这个比例应该高于95%，如果比例较低，可以适当调高对象池的大小。
    2. 及时清理对象池，避免无谓的占用内存空间。
    

*CPU使用率优化*

卡顿和掉帧是对用户体验影响最大的性能问题，甚至有同学认为这类问题要归类为app的bug，而是单纯的性能问题。造成卡顿的原因是在UI线程做了太多事情，无论是app自己的逻辑还是系统的GC。显然，减少卡顿的方法是尽量少的在UI线程做和UI无关的事情。可以使用Android Studio的Method Tracing或者DDMS的Method Profiling。对于CPU使用率的优化没有一定的范式，需要根据实际情况来找具体的办法。这里有两点经验：
    1. 对循环尤其是多层循环需要特别留意
    2. 尽可能的使用已经存在的算法和API而不是自己实现一套，除非有足够的证据证明自己实现的方法更好。例如在ME中，之前我们自己实现了一套在目录中寻找是否存在制定文件名文件的方法，造成了比较高的CPU占用。而实际上可以用File.exists()来优化这个判断。

*优化动画*

安卓为我们提供了多种实现动画的方式，每种都有各自的优缺点，由于本文篇幅限制，就不在此展开分析背后的原理了。在ME优化过程中对动画做了一些优化，下面列举一些我们的实践供大家参考：

1. 对于位移、伸缩、旋转和透明度等动画操作，尽量使用View.animate()方法返回的ViewPropertyAnimator对象来实现动画，并且使用withLayer方法让动画运行在硬件层。
2. 对于无法使用ViewPropertyAnimator实现的位移、伸缩、旋转和透明度等动画，在onAnimationStart时设置动画中变化视图的layer type为hardware，在结束时还原。
3. 对于帧动画通常我们会使用AnimationDrawable来实现。但是如果动画图片相对比较大、帧数较多，很可能造成加载时间较长的问题。这种情况下可以使用TextureView来自行展现。由于TextureView可以在独立的线程中进行图片的解码，可以重用一份bitmap内存，比使用AnimationDrawable要节省内存开销以及可以更快的开始动画。

*优化布局层次*

通常的Android界面都是有很多不同的空间组成的，为了把控件绘制在适当的位置，在绘制前会进行测量和布局。一个Activity的布局层数越多，测量和布局的负担就越重。我们可以使用DDMS里的Hierarchy View功能来分析app的布局。为了使用这个功能，需要在app中添加一个View Server class[代码链接](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java) ， 然后在Activity的生命周期中插入一些代码。具体使用方式就不再赘述了，下面讲一下优化层次的一些经验：

1. 如果在Tree View中观察到有一个节点（A）只有一个子节点（B），通常这个节点是可以优化掉的。如果A和B都在同一个layout文件中，意味着A包裹着B，那么可以直接去掉节点A，让节点B直接出现在A的位置。如果B是一个fragment，或者是一个include标签，可以把B的根元素改为merge。
2. 如果发现一个relative layout下包含少量层次，且每个层次的节点数也不多，可以考虑通过调整layout的方式把relative layout之下的元素都合并到它里面，而不是再用其他layout包裹。这种方式需要花一些时间来调整。
3. 如果在布局中有些分支不是所有情况下都展现给用户看的，可以使用ViewStub来替代这些元素，再需要展示的时候再inflate它，这样不仅可以减少布局层次，还可以节省内存。

##所有问题的终极解决之道

也许上面所有的工具和方法都没有办法解决你的疑惑，但是也不需要沮丧，因为Android是个开源的系统

#READ THE FXXKING SOURCE CODE
